<script>
  /**
   * Class: PatternRenderer
   * æˆæ¥­ãƒ‘ã‚¿ãƒ¼ãƒ³ã”ã¨ã®UIæç”»ãƒ»æ“ä½œã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
   */
  class PatternRenderer {
    constructor() {
      this.container = null;
      this.mode = 'INPUT'; // INPUT (å…¥åŠ›) or REFLECTION (æŒ¯ã‚Šè¿”ã‚Š)
      this.currentData = null; // ç¾åœ¨ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿
    }

    /**
     * ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¿œã˜ãŸå…¥åŠ›UIã‚’æç”»ã—ã¾ã™
     * @param {string} patternType - SLIDER, TAGS, QUADRANT, RANKING, CURVE
     * @param {HTMLElement} container - æç”»å¯¾è±¡ã®è¦ªè¦ç´ 
     * @param {Object} options - ãƒ‘ã‚¿ãƒ¼ãƒ³è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³
     * @param {string} mode - INPUT or REFLECTION
     */
    render(patternType, container, options, mode = 'INPUT') {
      this.container = container;
      this.mode = mode;
      this.container.innerHTML = ''; // Clear

      console.log(`Rendering Pattern: ${patternType} in ${mode} mode`, options);

      switch (patternType) {
        case 'SLIDER':
          this.renderSlider(options);
          break;
        case 'TAGS':
          this.renderTags(options);
          break;
        case 'QUADRANT':
          this.renderQuadrant(options);
          break;
        case 'RANKING':
          this.renderRanking(options);
          break;
        case 'CURVE':
          this.renderCurve(options);
          break;
        case 'MANDALA':
          this.renderMandala(options);
          break;
        case 'ACTION':
          this.renderAction(options);
          break;
        default:
          this.container.innerHTML = '<div class="alert alert-danger">ä¸æ˜ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™</div>';
      }
    }
    /**
     * ã¿ã‚“ãªã®æ„è¦‹ãƒªã‚¹ãƒˆã‚’æç”»ã—ã¾ã™
     * @param {string} patternType 
     * @param {HTMLElement} container 
     * @param {Array} opinions - [{value, text, studentName}, ...]
     */
    /**
     * JSONæ–‡å­—åˆ—ã‚’å®‰å…¨ã«ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
     */
    _parseValue(val) {
      if (typeof val === 'object' && val !== null) return val;
      if (typeof val === 'string') {
        try { return JSON.parse(val); } catch (e) { return val; }
      }
      return val;
    }

    /**
     * ã¿ã‚“ãªã®æ„è¦‹ãƒªã‚¹ãƒˆã‚’æç”»ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥ã«æœ€é©åŒ–ã•ã‚ŒãŸè¡¨ç¤ºï¼‰
     */
    renderOpinionList(patternType, container, opinions, options) {
      container.innerHTML = '';
      if (!opinions || opinions.length === 0) {
        container.innerHTML = '<div class="text-muted text-center p-3">ã¾ã æ„è¦‹ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }

      // ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥ã«æœ€é©ãªè¡¨ç¤ºæ–¹å¼ã‚’é¸æŠ
      switch (patternType) {
        case 'SLIDER':
          this._renderSliderOpinions(container, opinions, options);
          break;
        case 'TAGS':
          this._renderTagsOpinions(container, opinions, options);
          break;
        case 'QUADRANT':
          this._renderQuadrantOpinions(container, opinions, options);
          break;
        case 'RANKING':
          this._renderRankingOpinions(container, opinions, options);
          break;
        case 'CURVE':
          this._renderCurveOpinions(container, opinions, options);
          break;
        case 'MANDALA':
          this._renderMandalaOpinions(container, opinions, options);
          break;
        case 'ACTION':
          this._renderActionOpinions(container, opinions, options);
          break;
        default:
          this._renderDefaultOpinions(container, opinions);
      }
    }

    /**
     * SLIDER: åˆ†å¸ƒãƒãƒ¼ + æ„è¦‹ä¸€è¦§
     */
    _renderSliderOpinions(container, opinions, options) {
      const opts = options || {};
      const minLabel = opts.minLabel || 'A';
      const maxLabel = opts.maxLabel || 'B';

      // åˆ†å¸ƒãƒãƒ¼ã‚’è¡¨ç¤º
      const values = opinions.map(o => Number(o.value) || 50);
      const avg = Math.round(values.reduce((a, b) => a + b, 0) / values.length);

      let html = `<div class="mb-3 p-2 bg-white rounded border">
        <div class="d-flex justify-content-between small text-muted mb-1">
          <span>${minLabel}</span>
          <span class="fw-bold">${opinions.length}äººã®å¹³å‡: ${avg}</span>
          <span>${maxLabel}</span>
        </div>
        <div class="position-relative bg-light rounded" style="height: 24px;">`;

      // å„å›ç­”ã‚’ãƒ‰ãƒƒãƒˆã§è¡¨ç¤º
      values.forEach(v => {
        html += `<div class="position-absolute bg-primary rounded-circle" style="width: 8px; height: 8px; left: ${v}%; top: 50%; transform: translate(-50%, -50%); opacity: 0.6;"></div>`;
      });

      // å¹³å‡ãƒãƒ¼ã‚«ãƒ¼
      html += `<div class="position-absolute bg-danger" style="width: 3px; height: 100%; left: ${avg}%; top: 0;"></div>`;
      html += `</div></div>`;

      // ãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹ä¸€è¦§
      html += this._buildTextList(opinions, (op) => {
        return `<span class="badge bg-primary rounded-pill me-2">${op.value}</span>`;
      });

      container.innerHTML = html;
    }

    /**
     * TAGS: ã‚«ãƒ†ã‚´ãƒªåˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦è¡¨ç¤º
     */
    _renderTagsOpinions(container, opinions, options) {
      // ã‚¿ã‚°ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
      const groups = {};
      opinions.forEach(op => {
        const tag = op.value || 'ä¸æ˜';
        if (!groups[tag]) groups[tag] = [];
        groups[tag].push(op);
      });

      const colors = ['bg-primary', 'bg-success', 'bg-warning text-dark', 'bg-info text-dark', 'bg-danger', 'bg-secondary'];

      let html = `<div class="mb-3">`;
      // ã‚µãƒãƒªãƒ¼ãƒãƒƒã‚¸
      html += `<div class="d-flex flex-wrap gap-2 mb-3 justify-content-center">`;
      Object.keys(groups).forEach((tag, idx) => {
        const color = colors[idx % colors.length];
        html += `<span class="badge ${color} fs-6 px-3 py-2">${tag} <span class="badge bg-light text-dark ms-1">${groups[tag].length}</span></span>`;
      });
      html += `</div>`;

      // ã‚°ãƒ«ãƒ¼ãƒ—åˆ¥æ„è¦‹
      Object.keys(groups).forEach((tag, idx) => {
        const color = colors[idx % colors.length];
        groups[tag].forEach(op => {
          if (op.text) {
            html += `<div class="card mb-2 border-start border-3" style="border-color: var(--bs-${color.replace('bg-', '').replace(' text-dark', '')}) !important;">
              <div class="card-body py-2 px-3">
                <span class="badge ${color} me-2">${tag}</span>
                <span>${op.text}</span>
              </div>
            </div>`;
          }
        });
      });
      html += `</div>`;

      container.innerHTML = html;
    }

    /**
     * QUADRANT: ãƒŸãƒ‹æ•£å¸ƒå›³ + ãƒ†ã‚­ã‚¹ãƒˆä¸€è¦§
     */
    _renderQuadrantOpinions(container, opinions, options) {
      const opts = options || {};
      const xMin = opts.xAxisLabel?.[0] || 'å·¦';
      const xMax = opts.xAxisLabel?.[1] || 'å³';
      const yMin = opts.yAxisLabel?.[0] || 'ä¸‹';
      const yMax = opts.yAxisLabel?.[1] || 'ä¸Š';

      // ãƒŸãƒ‹æ•£å¸ƒå›³
      let html = `<div class="mb-3 p-2 bg-white rounded border">
        <div class="position-relative mx-auto" style="width: 100%; max-width: 250px; aspect-ratio: 1/1;">
          <div class="w-100 h-100 bg-light border position-relative">
            <div class="position-absolute top-50 start-0 w-100 border-top border-secondary" style="opacity: 0.3;"></div>
            <div class="position-absolute start-50 top-0 h-100 border-start border-secondary" style="opacity: 0.3;"></div>
            <span class="position-absolute top-50 start-0 translate-middle-y small text-muted" style="font-size: 0.7rem; margin-left: 2px;">${xMin}</span>
            <span class="position-absolute top-50 end-0 translate-middle-y small text-muted" style="font-size: 0.7rem; margin-right: 2px;">${xMax}</span>
            <span class="position-absolute top-0 start-50 translate-middle-x small text-muted" style="font-size: 0.7rem; margin-top: 2px;">${yMax}</span>
            <span class="position-absolute bottom-0 start-50 translate-middle-x small text-muted" style="font-size: 0.7rem; margin-bottom: 2px;">${yMin}</span>`;

      // å„å›ç­”ã‚’ãƒ‰ãƒƒãƒˆã§è¡¨ç¤º
      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && typeof val === 'object') {
          const left = ((Number(val.x) + 100) / 200) * 100;
          const top = ((100 - Number(val.y)) / 200) * 100;
          html += `<div class="position-absolute bg-primary rounded-circle border border-white" style="width: 12px; height: 12px; left: ${left}%; top: ${top}%; transform: translate(-50%, -50%); opacity: 0.7;"></div>`;
        }
      });

      html += `</div></div></div>`;

      // ãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹
      html += this._buildTextList(opinions, (op) => {
        const val = this._parseValue(op.value);
        return val && typeof val === 'object'
          ? `<span class="badge bg-secondary me-2">x:${val.x} y:${val.y}</span>`
          : '';
      });

      container.innerHTML = html;
    }

    /**
     * RANKING: é›†è¨ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º
     */
    _renderRankingOpinions(container, opinions, options) {
      // å„å›ç­”ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’é›†è¨ˆï¼ˆ1ä½ã«é…ç‚¹3, 2ä½ã«2, 3ä½ã«1...ï¼‰
      const scores = {};
      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && val.items) {
          val.items.forEach((item, idx) => {
            if (!scores[item]) scores[item] = 0;
            scores[item] += Math.max(val.items.length - idx, 1);
          });
        }
      });

      const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);

      let html = `<div class="mb-3">
        <div class="text-center small text-muted mb-2">ã¿ã‚“ãªã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°é›†è¨ˆï¼ˆ${opinions.length}äººï¼‰</div>`;

      if (sorted.length > 0) {
        const maxScore = sorted[0][1];
        sorted.forEach(([item, score], idx) => {
          const pct = Math.round((score / maxScore) * 100);
          const medal = idx === 0 ? 'ğŸ¥‡' : idx === 1 ? 'ğŸ¥ˆ' : idx === 2 ? 'ğŸ¥‰' : `${idx + 1}.`;
          html += `<div class="d-flex align-items-center mb-1">
            <span class="me-2" style="min-width: 28px; text-align: center;">${medal}</span>
            <div class="flex-grow-1">
              <div class="d-flex justify-content-between small">
                <span class="fw-bold">${item}</span>
                <span class="text-muted">${score}pt</span>
              </div>
              <div class="progress" style="height: 6px;">
                <div class="progress-bar" style="width: ${pct}%"></div>
              </div>
            </div>
          </div>`;
        });
      }

      html += `</div>`;

      // ãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹
      html += this._buildTextList(opinions, (op) => {
        const val = this._parseValue(op.value);
        const top = val?.items?.[0] || '-';
        return `<span class="badge bg-primary me-2">1ä½: ${top}</span>`;
      });

      container.innerHTML = html;
    }

    /**
     * CURVE: é‡ã­åˆã‚ã›æŠ˜ã‚Œç·šãƒãƒ£ãƒ¼ãƒˆ
     */
    _renderCurveOpinions(container, opinions, options) {
      const opts = options || {};
      const scenes = opts.scenes || ['ã¯ã˜ã‚', 'å±•é–‹', 'å±±å ´', 'çµæœ«'];

      // ãƒãƒ£ãƒ¼ãƒˆç”¨Canvas
      const canvasId = 'opinion-curve-chart-' + Date.now();
      let html = `<div class="mb-3 p-2 bg-white rounded border">
        <div class="text-center small text-muted mb-1">ã¿ã‚“ãªã®å¿ƒæƒ…æ›²ç·šï¼ˆ${opinions.length}äººï¼‰</div>
        <div style="height: 150px;"><canvas id="${canvasId}"></canvas></div>
      </div>`;

      // ãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹
      html += this._buildTextList(opinions, () => {
        return `<span class="badge bg-secondary me-2">å¿ƒæƒ…æ›²ç·š</span>`;
      });

      container.innerHTML = html;

      // ãƒãƒ£ãƒ¼ãƒˆæç”»
      setTimeout(() => {
        const ctx = document.getElementById(canvasId);
        if (!ctx) return;

        const datasets = [];
        // å¹³å‡ç·šãƒ‡ãƒ¼ã‚¿
        const avgData = new Array(scenes.length).fill(0);
        let count = 0;

        opinions.forEach((op, idx) => {
          const val = this._parseValue(op.value);
          if (val && val.data) {
            const data = val.data.map(d => d.value);
            // å¹³å‡ã«åŠ ç®—
            data.forEach((v, i) => { avgData[i] += v; });
            count++;
            // å€‹åˆ¥ç·šï¼ˆè–„ã‚ï¼‰
            datasets.push({
              data: data,
              borderColor: `hsla(${(idx * 37) % 360}, 70%, 60%, 0.3)`,
              borderWidth: 1,
              pointRadius: 0,
              tension: 0.3,
              fill: false
            });
          }
        });

        // å¹³å‡ç·šï¼ˆå¤ªã‚ï¼‰
        if (count > 0) {
          datasets.push({
            label: 'ã¿ã‚“ãªã®å¹³å‡',
            data: avgData.map(v => Math.round(v / count)),
            borderColor: 'rgb(255, 99, 132)',
            borderWidth: 3,
            pointRadius: 4,
            tension: 0.3,
            fill: false
          });
        }

        new Chart(ctx, {
          type: 'line',
          data: { labels: scenes, datasets: datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { min: 0, max: 100, display: false },
              x: { ticks: { font: { size: 10 } } }
            },
            plugins: { legend: { display: false } },
            animation: false
          }
        });
      }, 100);
    }

    /**
     * MANDALA: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¦ãƒ‰é¢¨è¡¨ç¤º
     */
    _renderMandalaOpinions(container, opinions, options) {
      // å…¨å›ç­”ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’é›†ç´„
      const wordCounts = {};
      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && val.items) {
          val.items.filter(v => v && v.trim()).forEach(item => {
            const word = item.trim();
            wordCounts[word] = (wordCounts[word] || 0) + 1;
          });
        }
      });

      const sorted = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);

      let html = `<div class="mb-3">
        <div class="text-center small text-muted mb-2">ã¿ã‚“ãªãŒæ›¸ã„ãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆ${opinions.length}äººï¼‰</div>
        <div class="d-flex flex-wrap gap-1 justify-content-center mb-3">`;

      sorted.slice(0, 20).forEach(([word, count]) => {
        const size = count >= 3 ? 'fs-5 px-3 py-1' : count >= 2 ? 'px-2 py-1' : 'small px-2';
        html += `<span class="badge bg-warning text-dark ${size}">${word}<sup class="ms-1">${count}</sup></span>`;
      });

      html += `</div></div>`;

      // ãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹
      html += this._buildTextList(opinions, (op) => {
        const val = this._parseValue(op.value);
        const preview = val?.items?.filter(v => v).slice(0, 2).join(', ') || '';
        return preview ? `<span class="badge bg-warning text-dark me-2">${preview}...</span>` : '';
      });

      container.innerHTML = html;
    }

    /**
     * ACTION: å®£è¨€ã‚«ãƒ¼ãƒ‰ä¸€è¦§
     */
    _renderActionOpinions(container, opinions, options) {
      let html = `<div class="text-center small text-muted mb-2">ã¿ã‚“ãªã®è¡Œå‹•å®£è¨€ï¼ˆ${opinions.length}äººï¼‰</div>`;

      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && typeof val === 'object') {
          html += `<div class="card mb-2 border-start border-3 border-success">
            <div class="card-body py-2 px-3">
              <div class="fw-bold text-success small"><i class="bi bi-megaphone-fill"></i> è¡Œå‹•å®£è¨€</div>
              ${val.when ? `<div class="small"><span class="text-muted">ã„ã¤:</span> ${val.when}</div>` : ''}
              ${val.who ? `<div class="small"><span class="text-muted">èª°ã«:</span> ${val.who}</div>` : ''}
              ${val.what ? `<div class="small fw-bold"><span class="text-muted">ä½•ã‚’:</span> ${val.what}</div>` : ''}
              ${op.text ? `<div class="small text-muted mt-1 border-top pt-1">${op.text}</div>` : ''}
            </div>
          </div>`;
        }
      });

      container.innerHTML = html;
    }

    /**
     * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤º
     */
    _renderDefaultOpinions(container, opinions) {
      container.innerHTML = this._buildTextList(opinions, (op) => {
        return `<span class="badge bg-secondary me-2">${op.value}</span>`;
      });
    }

    /**
     * ãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹ä¸€è¦§ã®å…±é€šãƒ“ãƒ«ãƒ€ãƒ¼
     */
    _buildTextList(opinions, badgeBuilder) {
      const withText = opinions.filter(op => op.text && op.text.trim());
      if (withText.length === 0) return '';

      let html = '';
      withText.forEach(op => {
        const badge = badgeBuilder(op);
        html += `<div class="card mb-2" style="border-left: 4px solid #17a2b8;">
          <div class="card-body py-2 px-3">
            <div class="mb-1">${badge}</div>
            <div class="small">${op.text}</div>
          </div>
        </div>`;
      });
      return html;
    }

    /**
     * ç¾åœ¨ã®å…¥åŠ›å€¤ã‚’å–å¾—ã—ã¾ã™
     * @return {Object|null} - é€ä¿¡ãƒ‡ãƒ¼ã‚¿å½¢å¼ (value, text, coordinates, etc.)
     */
    getValue() {
      // å„ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã§è¨­å®šã—ãŸ input è¦ç´ ãªã©ã‹ã‚‰å€¤ã‚’å–å¾—
      // æ±ç”¨çš„ãªä»•çµ„ã¿ã«ã™ã‚‹ãŸã‚ã€data-attributeç­‰ã‚’åˆ©ç”¨ã™ã‚‹ã‹ã€
      // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‚’æ›´æ–°ã™ã‚‹å½¢ã«ã™ã‚‹

      // ä»®ã®å®Ÿè£…: å„renderãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ .pattern-input ã‚¯ãƒ©ã‚¹ã‚’æŒã¤è¦ç´ ã«å€¤ã‚’å…¥ã‚Œã‚‹æƒ³å®š
      // MANDALA/ACTIONã®å ´åˆã¯ã€ã‚³ãƒ³ãƒ†ãƒŠå†…ã®è¤‡æ•°ã®inputã‹ã‚‰å€¤ã‚’é›†ç´„ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„

      // MANDALA
      if (this.container.querySelector('.mandala-grid')) {
        const inputs = this.container.querySelectorAll('.mandala-input');
        const center = this.container.querySelector('.mandala-center')?.innerText || '';
        const values = Array.from(inputs).map(input => input.value);
        return { center: center, items: values };
      }

      // ACTION
      if (this.container.querySelector('.action-card')) {
        const when = document.getElementById('action-when')?.value || '';
        const who = document.getElementById('action-who')?.value || '';
        const what = document.getElementById('action-what')?.value || '';
        return { when: when, who: who, what: what };
      }

      // RANKING
      if (this.container.querySelector('.ranking-list')) {
        const items = Array.from(this.container.querySelectorAll('.ranking-item')).map(el => el.dataset.value);
        return { items: items };
      }

      // CURVE
      if (this.container.querySelector('.curve-container')) {
        const inputs = this.container.querySelectorAll('.curve-input');
        // labelsã¯data-labelå±æ€§ã¨ã‹ã‹ã‚‰å–ã‚‹ã‹ã€optionsã‹ã‚‰å–ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€
        // ã“ã“ã§ã¯ä¿å­˜ã™ã‚‹ã®ã¯ { label: 'ã‚·ãƒ¼ãƒ³å', value: 50 } ã®é…åˆ—ã«ã™ã‚‹
        const data = Array.from(inputs).map(input => {
          return { label: input.dataset.label, value: Number(input.value) };
        });
        return { data: data };
      }

      const input = this.container.querySelector('.pattern-input');
      if (!input) return null;

      // JSONæ–‡å­—åˆ—ã¨ã—ã¦æ ¼ç´ã•ã‚Œã¦ã„ã‚‹å ´åˆã‚„ã€å˜ç´”ãªå€¤ã®å ´åˆ
      const val = input.value;
      try {
        return JSON.parse(val);
      } catch (e) {
        return val;
      }
    }

    // =================================================================
    // 1. SLIDER (æ—¢å­˜äº’æ›)
    // =================================================================
    renderSlider(options) {
      // æ—¢å­˜UIã®å†ç¾ (IDç­‰ã¯æ—¢å­˜ã®CSS/JSã¨æ•´åˆæ€§ã‚’ã¨ã‚‹ãŸã‚èª¿æ•´ãŒå¿…è¦ã ãŒã€
      // ã“ã“ã§ã¯æ–°è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã—ã¦ç‹¬ç«‹ã•ã›ã‚‹)

      const minLabel = options.minLabel || 'A';
      const maxLabel = options.maxLabel || 'B';
      const initialVal = 50;
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      const html = `
      <div class="mb-4">
        <div class="d-flex justify-content-between mb-3">
          <span class="badge bg-secondary text-wrap fs-5 p-3" style="width: 45%;">${minLabel}</span>
          <span class="badge bg-secondary text-wrap fs-5 p-3" style="width: 45%;">${maxLabel}</span>
        </div>
        <input type="range" class="form-range custom-range py-4 pattern-input" min="0" max="100" step="1" 
          value="${initialVal}" 
          id="${prefix}pattern-slider"
          oninput="document.getElementById('${prefix}slider-val').innerText = this.value; this.style.background = 'linear-gradient(90deg, #0d6efd ' + this.value + '%, #dee2e6 ' + this.value + '%)';"
          style="height: 3rem;">
        <div class="text-center mb-3">
          <span id="${prefix}slider-val" class="fw-bold display-4">${initialVal}</span>
        </div>
      </div>
    `;
      this.container.innerHTML = html;
    }

    // =================================================================
    // 2. TAGS (æ—¢å­˜äº’æ›)
    // =================================================================
    renderTags(options) {
      const tags = options.tags || ['å…±æ„Ÿ', 'ç–‘å•', 'ç´å¾—', 'é©šã'];
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      // éš ã—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      const hidden = document.createElement('input');
      hidden.type = 'hidden';
      hidden.className = 'pattern-input';
      hidden.id = `${prefix}pattern-tags-val`;
      this.container.appendChild(hidden);

      const wrapper = document.createElement('div');
      wrapper.className = 'd-flex flex-wrap gap-3 justify-content-center';

      tags.forEach(tag => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-outline-primary btn-lg rounded-pill px-4 py-2';
        btn.innerText = tag;
        btn.onclick = (e) => {
          // Toggle logic
          const allBtns = wrapper.querySelectorAll('.btn');
          allBtns.forEach(b => {
            b.classList.remove('btn-primary', 'text-white');
            b.classList.add('btn-outline-primary');
          });
          e.target.classList.remove('btn-outline-primary');
          e.target.classList.add('btn-primary', 'text-white');

          hidden.value = tag;
          // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
          e.target.animate([
            { transform: 'scale(1)' },
            { transform: 'scale(1.1)' },
            { transform: 'scale(1)' }
          ], { duration: 200 });
        };
        wrapper.appendChild(btn);
      });

      this.container.appendChild(wrapper);
    }

    // =================================================================
    // 3. QUADRANT (åº§æ¨™è»¸ - NEW)
    // =================================================================
    renderQuadrant(options) {
      const xLabelMin = options.xAxisLabel?.[0] || 'å·¦';
      const xLabelMax = options.xAxisLabel?.[1] || 'å³';
      const yLabelMin = options.yAxisLabel?.[0] || 'ä¸‹';
      const yLabelMax = options.yAxisLabel?.[1] || 'ä¸Š';
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      // ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
      const html = `
      <div class="position-relative mx-auto mb-4" style="width: 100%; max-width: 400px; aspect-ratio: 1/1;">
        <!-- èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰ -->
        <div class="w-100 h-100 border bg-light position-relative" id="${prefix}quad-area" style="cursor: crosshair;">
          <!-- è»¸ç·š -->
          <div class="position-absolute top-50 start-0 w-100 border-top border-secondary"></div>
          <div class="position-absolute start-50 top-0 h-100 border-start border-secondary"></div>
          
          <!-- ãƒ©ãƒ™ãƒ« -->
          <span class="position-absolute top-50 start-0 translate-middle-y ms-1 bg-white small px-1 border rounded">${xLabelMin}</span>
          <span class="position-absolute top-50 end-0 translate-middle-y me-1 bg-white small px-1 border rounded">${xLabelMax}</span>
          <span class="position-absolute bottom-0 start-50 translate-middle-x mb-1 bg-white small px-1 border rounded">${yLabelMin}</span>
          <span class="position-absolute top-0 start-50 translate-middle-x mt-1 bg-white small px-1 border rounded">${yLabelMax}</span>

          <!-- ãƒ”ãƒ³ (ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½) -->
          <div id="${prefix}quad-pin" class="position-absolute bg-primary rounded-circle shadow border border-white" 
               style="width: 24px; height: 24px; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: grab; z-index: 10;">
          </div>
        </div>
        <p class="text-center text-muted small mt-2">ãƒ”ãƒ³ã‚’å‹•ã‹ã—ã¦ä½ç½®ã‚’æ±ºã‚ã¦ã­</p>
        
        <!-- å€¤ä¿æŒç”¨ -->
        <input type="hidden" class="pattern-input" id="${prefix}quad-val" value='{"x":0, "y":0}'>
      </div>
    `;
      this.container.innerHTML = html;

      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š (ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—)
      this.setupQuadrantEvents(prefix);
    }

    setupQuadrantEvents(prefix) {
      const area = document.getElementById(`${prefix}quad-area`);
      const pin = document.getElementById(`${prefix}quad-pin`);
      const input = document.getElementById(`${prefix}quad-val`);

      let isDragging = false;

      const updatePosition = (clientX, clientY) => {
        const rect = area.getBoundingClientRect();
        let x = clientX - rect.left;
        let y = clientY - rect.top;

        // ç¯„å›²åˆ¶é™
        x = Math.max(0, Math.min(x, rect.width));
        y = Math.max(0, Math.min(y, rect.height));

        // è¡¨ç¤ºæ›´æ–°
        pin.style.left = `${x}px`;
        pin.style.top = `${y}px`;

        // æ­£è¦åŒ– (-100 to 100)
        const normX = Math.round(((x / rect.width) * 200) - 100);
        const normY = Math.round(-((y / rect.height) * 200) + 100); // Yã¯ä¸ŠãŒãƒ—ãƒ©ã‚¹

        input.value = JSON.stringify({ x: normX, y: normY });
      };

      // Mouse Events
      pin.addEventListener('mousedown', () => { isDragging = true; pin.style.cursor = 'grabbing'; });
      window.addEventListener('mouseup', () => { isDragging = false; pin.style.cursor = 'grab'; });
      window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        updatePosition(e.clientX, e.clientY);
      });

      // Click to move
      area.addEventListener('click', (e) => {
        updatePosition(e.clientX, e.clientY);
      });

      // Touch Events
      pin.addEventListener('touchstart', (e) => { isDragging = true; e.preventDefault(); }, { passive: false });
      window.addEventListener('touchend', () => { isDragging = false; });
      window.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        updatePosition(touch.clientX, touch.clientY);
      }, { passive: false });
    }

    // =================================================================
    // 4. RANKING (ãƒ©ãƒ³ã‚­ãƒ³ã‚°)
    // =================================================================
    renderRanking(options) {
      const items = options.items || ['é …ç›®A', 'é …ç›®B', 'é …ç›®C'];
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      let html = `<div class="ranking-list mx-auto" style="max-width: 400px;">`;
      html += `<p class="text-center text-muted small mb-2"><i class="bi bi-hand-index-thumb"></i> <ruby>é•·æŠ¼<rt>ãªãŒãŠ</rt></ruby>ã—ã§ãƒ‰ãƒ©ãƒƒã‚°ã€ã¾ãŸã¯<ruby>çŸ¢å°<rt>ã‚„ã˜ã‚‹ã—</rt></ruby>ãƒœã‚¿ãƒ³ã§<ruby>ä¸¦<rt>ãªã‚‰</rt></ruby>ã¹<ruby>æ›¿<rt>ã‹</rt></ruby>ãˆã¦ã­ã€‚<br><ruby>ä¸Š<rt>ã†ãˆ</rt></ruby>ã«ã‚ã‚‹ã»ã©ã€Œ<ruby>å¤§äº‹<rt>ã ã„ã˜</rt></ruby>ã€ã§ã™ã€‚</p>`;

      items.forEach((item, index) => {
        html += `
          <div class="card mb-2 ranking-item" data-value="${item}" id="${prefix}rank-item-${index}" draggable="true"
            style="cursor: grab; touch-action: none; user-select: none;">
            <div class="card-body p-2 d-flex align-items-center">
               <div class="me-2 text-muted" style="cursor:grab;"><i class="bi bi-grip-vertical fs-4"></i></div>
               <div class="me-2 fw-bold fs-4 text-primary rank-num">${index + 1}</div>
               <div class="flex-grow-1 fw-bold">${item}</div>
               <div class="d-flex flex-column gap-1">
                 <button class="btn btn-sm btn-outline-secondary py-0 px-2" onclick="patternRenderer.moveRank(this, -1)">â–²</button>
                 <button class="btn btn-sm btn-outline-secondary py-0 px-2" onclick="patternRenderer.moveRank(this, 1)">â–¼</button>
               </div>
            </div>
          </div>
        `;
      });
      html += `</div>`;
      this.container.innerHTML = html;
      this.updateRankNumbers();
      this._initRankingDragDrop();
    }

    _initRankingDragDrop() {
      const list = this.container.querySelector('.ranking-list');
      if (!list) return;
      let dragItem = null;
      const self = this;

      // HTML5 Drag (desktop)
      list.addEventListener('dragstart', (e) => {
        dragItem = e.target.closest('.ranking-item');
        if (!dragItem) return;
        dragItem.style.opacity = '0.4';
        e.dataTransfer.effectAllowed = 'move';
      });
      list.addEventListener('dragover', (e) => {
        e.preventDefault();
        const target = e.target.closest('.ranking-item');
        if (target && target !== dragItem) {
          const rect = target.getBoundingClientRect();
          if (e.clientY < rect.top + rect.height / 2) {
            list.insertBefore(dragItem, target);
          } else {
            list.insertBefore(dragItem, target.nextSibling);
          }
        }
      });
      list.addEventListener('dragend', () => {
        if (dragItem) dragItem.style.opacity = '1';
        dragItem = null;
        self.updateRankNumbers();
      });

      // Touch drag (mobile/tablet)
      list.addEventListener('touchstart', (e) => {
        dragItem = e.target.closest('.ranking-item');
        if (!dragItem) return;
        dragItem.style.zIndex = '100';
        dragItem.style.boxShadow = '0 4px 16px rgba(0,0,0,0.2)';
      }, { passive: true });

      list.addEventListener('touchmove', (e) => {
        if (!dragItem) return;
        e.preventDefault();
        const touchY = e.touches[0].clientY;
        const items = Array.from(list.querySelectorAll('.ranking-item'));
        for (const item of items) {
          if (item === dragItem) continue;
          const rect = item.getBoundingClientRect();
          const mid = rect.top + rect.height / 2;
          if (touchY < mid && item.compareDocumentPosition(dragItem) & Node.DOCUMENT_POSITION_FOLLOWING) {
            list.insertBefore(dragItem, item); break;
          } else if (touchY > mid && item.compareDocumentPosition(dragItem) & Node.DOCUMENT_POSITION_PRECEDING) {
            list.insertBefore(dragItem, item.nextSibling); break;
          }
        }
      }, { passive: false });

      list.addEventListener('touchend', () => {
        if (dragItem) {
          dragItem.style.zIndex = '';
          dragItem.style.boxShadow = '';
          dragItem = null;
          self.updateRankNumbers();
        }
      });
    }

    moveRank(btn, direction) {
      const item = btn.closest('.ranking-item');
      const list = item.parentNode;
      const all = Array.from(list.children).filter(c => c.classList.contains('ranking-item'));
      const index = all.indexOf(item);

      if (direction === -1 && index > 0) {
        list.insertBefore(item, all[index - 1]);
      } else if (direction === 1 && index < all.length - 1) {
        list.insertBefore(item, all[index + 1].nextSibling);
      }
      item.style.transition = 'transform 0.2s';
      item.style.transform = 'scale(1.03)';
      setTimeout(() => { item.style.transform = ''; }, 200);
      this.updateRankNumbers();
    }

    updateRankNumbers() {
      if (!this.container) return;
      const items = this.container.querySelectorAll('.ranking-item');
      items.forEach((item, idx) => {
        const numEl = item.querySelector('.rank-num');
        numEl.innerText = idx + 1;
        if (idx === 0) item.classList.add('border-primary');
        else item.classList.remove('border-primary');
      });
    }

    // =================================================================
    // 5. CURVE (å¿ƒæƒ…æ›²ç·š - Timeline)
    // =================================================================
    renderCurve(options) {
      const scenes = options.scenes || ['ã¯ã˜ã‚', 'å±•é–‹', 'å±±å ´', 'çµæœ«'];
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      // Chartç”¨Canvas + Sliderç¾¤
      const html = `
        <div class="curve-container mx-auto" style="max-width: 500px;">
           <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ -->
           <div style="height: 150px; width: 100%; position: relative;">
              <canvas id="${prefix}curve-chart"></canvas>
           </div>
           
           <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ç¾¤ -->
           <div class="d-flex justify-content-between mt-3 gap-1 overflow-auto pb-3">
              ${scenes.map((scene, idx) => `
                 <div class="text-center" style="min-width: 60px; flex: 1;">
                    <div class="d-flex justify-content-center" style="height: 150px;">
                        <input type="range" class="form-range curve-input" 
                               orient="vertical" 
                               style="writing-mode: bt-lr; /* IE/Edge */ -webkit-appearance: slider-vertical; width: 8px;"
                               min="0" max="100" value="50" 
                               data-index="${idx}" 
                               data-label="${scene}"
                               oninput="patternRenderer.updateCurveChart('${prefix}')">
                    </div>
                    <small class="d-block mt-2 fw-bold text-truncate" title="${scene}">${scene}</small>
                 </div>
              `).join('')}
           </div>
        </div>
      `;

      this.container.innerHTML = html;

      // åˆå›ãƒãƒ£ãƒ¼ãƒˆæç”»
      setTimeout(() => this.initCurveChart(prefix, scenes), 100);
    }

    initCurveChart(prefix, scenes) {
      const ctx = document.getElementById(`${prefix}curve-chart`);
      if (!ctx) return;

      // æ—¢å­˜ãƒãƒ£ãƒ¼ãƒˆç ´æ£„ã®ãŸã‚ã®ç®¡ç†ãŒå¿…è¦ã ãŒã€
      // ç°¡æ˜“çš„ã« data-chart-id ç­‰ã§ç®¡ç†ã™ã‚‹ã‹ã€æ¯å›æ–°è¦ä½œæˆï¼ˆCanvasã”ã¨HTMLå†ç”Ÿæˆã—ã¦ã„ã‚‹ã®ã§OKï¼‰

      const initialData = new Array(scenes.length).fill(50);

      this.currentChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: scenes,
          datasets: [{
            label: 'æ°—æŒã¡',
            data: initialData,
            borderColor: 'rgb(75, 192, 192)',
            tension: 0.3,
            fill: true,
            backgroundColor: 'rgba(75, 192, 192, 0.2)'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { min: 0, max: 100, display: false },
            x: { display: false } // ãƒ©ãƒ™ãƒ«ã¯ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ä¸‹ã«ã‚ã‚‹ã®ã§éè¡¨ç¤ºã§ã‚‚OKã ãŒã€ã‚ã£ãŸã»ã†ãŒã‚ã‹ã‚Šã‚„ã™ã„ã‹ã‚‚
          },
          plugins: { legend: { display: false } },
          animation: false // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å„ªå…ˆ
        }
      });
    }

    updateCurveChart(prefix) {
      if (!this.currentChart) return;

      const inputs = this.container.querySelectorAll('.curve-input');
      const data = Array.from(inputs).map(input => Number(input.value));

      this.currentChart.data.datasets[0].data = data;
      this.currentChart.update();
    }

    // =================================================================
    // 6. MANDALA (ãƒãƒ³ãƒ€ãƒ©ãƒãƒ£ãƒ¼ãƒˆ - Type C)
    // =================================================================
    renderMandala(options) {
      const theme = options.centerTheme || 'ãƒ†ãƒ¼ãƒ';
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      // 3x3 Grid
      // Center is fixed text (theme)
      // Surrounding 8 are inputs

      let html = `
      <div class="mandala-grid mx-auto mb-4" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; max-width: 400px; aspect-ratio: 1/1;">
    `;

      // 0-8 indices. Center is 4.
      for (let i = 0; i < 9; i++) {
        if (i === 4) {
          // Center
          html += `
              <div class="d-flex align-items-center justify-content-center bg-primary text-white fw-bold rounded shadow-sm p-1 text-center mandala-center" style="aspect-ratio: 1/1; font-size: 1.1rem; overflow: hidden;">
                ${theme}
              </div>
            `;
        } else {
          // Surrounding Inputs
          html += `
              <textarea class="form-control text-center p-1 mandala-input" style="aspect-ratio: 1/1; resize: none; font-size: 0.9rem;" placeholder="è¦ç´ "></textarea>
            `;
        }
      }

      html += `</div>
      <p class="text-center text-muted small mt-2">ãƒ†ãƒ¼ãƒã‚’æ§‹æˆã™ã‚‹ã‚‚ã®ã‚’æ›¸ãå‡ºãã†</p>
    `;

      this.container.innerHTML = html;
    }

    // =================================================================
    // 7. ACTION (å®£è¨€ã‚«ãƒ¼ãƒ‰ - Type D)
    // =================================================================
    renderAction(options) {
      const prefix = this.mode === 'REFLECTION' ? 'ref-' : '';

      const html = `
        <div class="action-card card border-success mb-4 border-2">
           <div class="card-header bg-white text-success fw-bold text-center">
             <i class="bi bi-megaphone-fill"></i> ç§ã®è¡Œå‹•å®£è¨€
           </div>
           <div class="card-body bg-light">
             <div class="mb-3">
               <label class="form-label small text-muted"><i class="bi bi-clock"></i> ã„ã¤ï¼ˆå ´é¢ï¼‰</label>
               <input type="text" class="form-control" id="action-when" placeholder="æ˜æ—¥ã€å­¦æ ¡ã§...">
             </div>
             <div class="mb-3">
               <label class="form-label small text-muted"><i class="bi bi-person"></i> èª°ã«ï¼ˆå¯¾è±¡ï¼‰</label>
               <input type="text" class="form-control" id="action-who" placeholder="å‹é”ã«ã€å®¶æ—ã«...">
             </div>
             <div class="mb-3">
               <label class="form-label small text-muted"><i class="bi bi-check-circle"></i> ä½•ã‚’ã™ã‚‹ï¼ˆè¡Œå‹•ï¼‰</label>
               <textarea class="form-control" id="action-what" rows="2" placeholder="æŒ¨æ‹¶ã‚’ã™ã‚‹ã€æ‰‹ä¼ã†..."></textarea>
             </div>
           </div>
        </div>
      `;
      this.container.innerHTML = html;
    }

    // =================================================================
    // FULLSCREEN OPINION VIEW
    // ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥ã«ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æœ€é©åŒ–ã•ã‚ŒãŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§æç”»
    // å·¦å³åˆ†å‰²: QUADRANT, MANDALAï¼ˆå·¦ã«å›³ã€å³ã«æ„è¦‹ä¸€è¦§ï¼‰
    // ä¸Šä¸‹åˆ†å‰²: SLIDER, TAGS, RANKING, CURVE, ACTIONï¼ˆä¸Šã«å›³ã€ä¸‹ã«æ„è¦‹ä¸€è¦§ï¼‰
    // =================================================================

    renderOpinionListFullscreen(patternType, container, opinions, options) {
      container.innerHTML = '';
      if (!opinions || opinions.length === 0) {
        container.innerHTML = '<div class="text-center text-muted fs-3 py-5"><i class="bi bi-chat-dots d-block fs-1 mb-3"></i>ã¾ã æ„è¦‹ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }

      const opts = options || {};
      const isHorizontal = (patternType === 'QUADRANT' || patternType === 'MANDALA');

      if (isHorizontal) {
        this._fsRenderHorizontal(patternType, container, opinions, opts);
      } else {
        this._fsRenderVertical(patternType, container, opinions, opts);
      }
    }

    // --- Horizontal Layout (Left: Viz, Right: List) ---
    _fsRenderHorizontal(patternType, container, opinions, opts) {
      const wrapper = document.createElement('div');
      wrapper.className = 'fs-layout-horizontal';

      const vizPanel = document.createElement('div');
      vizPanel.className = 'fs-viz';

      const listPanel = document.createElement('div');
      listPanel.className = 'fs-list';

      wrapper.appendChild(vizPanel);
      wrapper.appendChild(listPanel);
      container.appendChild(wrapper);

      if (patternType === 'QUADRANT') {
        this._fsQuadrantViz(vizPanel, opinions, opts);
      } else {
        this._fsMandalaViz(vizPanel, opinions, opts);
      }

      this._fsTextCards(listPanel, opinions, patternType);
    }

    // --- Vertical Layout (Top: Viz, Bottom: List) ---
    _fsRenderVertical(patternType, container, opinions, opts) {
      const wrapper = document.createElement('div');
      wrapper.className = 'fs-layout-vertical';

      const vizSection = document.createElement('div');
      vizSection.className = 'fs-viz-box';

      const listSection = document.createElement('div');

      wrapper.appendChild(vizSection);
      wrapper.appendChild(listSection);
      container.appendChild(wrapper);

      switch (patternType) {
        case 'SLIDER':
          this._fsSliderViz(vizSection, opinions, opts);
          this._fsTextCards(listSection, opinions, patternType);
          break;
        case 'TAGS':
          this._fsTagsViz(vizSection, opinions, opts);
          this._fsTextCards(listSection, opinions, patternType);
          break;
        case 'RANKING':
          this._fsRankingViz(vizSection, opinions, opts);
          this._fsTextCards(listSection, opinions, patternType);
          break;
        case 'CURVE':
          this._fsCurveViz(vizSection, opinions, opts);
          this._fsTextCards(listSection, opinions, patternType);
          break;
        case 'ACTION':
          vizSection.remove();
          this._fsActionCards(listSection, opinions);
          break;
        default:
          vizSection.remove();
          this._fsTextCards(listSection, opinions, patternType);
      }
    }

    // =========================================================
    // FULLSCREEN: SLIDER (Top-Bottom)
    // åˆ†å¸ƒãƒãƒ¼ï¼ˆå¤§ï¼‰+ æ„è¦‹ã‚«ãƒ¼ãƒ‰
    // =========================================================
    _fsSliderViz(container, opinions, opts) {
      const minLabel = opts.minLabel || 'A';
      const maxLabel = opts.maxLabel || 'B';
      const values = opinions.map(o => Number(o.value) || 50);
      const avg = Math.round(values.reduce((a, b) => a + b, 0) / values.length);

      let html = `
        <div class="text-center mb-3">
          <span class="badge bg-primary bg-opacity-10 text-primary fs-5 px-4 py-2">
            <i class="bi bi-people-fill me-1"></i>${opinions.length}äººã®<ruby>å›ç­”<rt>ã‹ã„ã¨ã†</rt></ruby>
          </span>
        </div>
        <div class="d-flex justify-content-between mb-2 px-1">
          <span class="fw-bold fs-4 text-primary">${minLabel}</span>
          <span class="fw-bold fs-4 text-danger">${maxLabel}</span>
        </div>
        <div class="position-relative bg-light rounded-pill mx-1" style="height: 52px; border: 2px solid #dee2e6;">`;

      values.forEach(v => {
        html += `<div class="position-absolute bg-primary rounded-circle border border-2 border-white shadow-sm"
          style="width: 18px; height: 18px; left: ${v}%; top: 50%; transform: translate(-50%, -50%); opacity: 0.7;"></div>`;
      });

      html += `<div class="position-absolute" style="left: ${avg}%; top: -12px; transform: translateX(-50%); z-index: 5;">
          <div class="bg-danger text-white fw-bold px-3 py-1 rounded-pill text-center" style="font-size: 0.85rem; white-space: nowrap;">
            <ruby>å¹³å‡<rt>ã¸ã„ãã‚“</rt></ruby> ${avg}
          </div>
          <div class="bg-danger mx-auto" style="width: 3px; height: 60px;"></div>
        </div>`;

      html += `</div>`;
      container.innerHTML = html;
    }

    // =========================================================
    // FULLSCREEN: TAGS (Top-Bottom)
    // ã‚¿ã‚°é›†è¨ˆãƒãƒƒã‚¸ï¼ˆå¤§ï¼‰+ ã‚°ãƒ«ãƒ¼ãƒ—åˆ¥æ„è¦‹
    // =========================================================
    _fsTagsViz(container, opinions, opts) {
      const groups = {};
      opinions.forEach(op => {
        const tag = op.value || 'ä¸æ˜';
        if (!groups[tag]) groups[tag] = [];
        groups[tag].push(op);
      });

      const colors = ['primary', 'success', 'warning', 'info', 'danger', 'secondary'];
      const sortedTags = Object.keys(groups).sort((a, b) => groups[b].length - groups[a].length);

      let html = `
        <div class="text-center mb-3">
          <span class="badge bg-primary bg-opacity-10 text-primary fs-5 px-4 py-2">
            <i class="bi bi-people-fill me-1"></i>${opinions.length}äººã®<ruby>å›ç­”<rt>ã‹ã„ã¨ã†</rt></ruby>
          </span>
        </div>
        <div class="d-flex flex-wrap gap-3 justify-content-center">`;

      sortedTags.forEach((tag, idx) => {
        const color = colors[idx % colors.length];
        const count = groups[tag].length;
        const pct = Math.round((count / opinions.length) * 100);
        html += `<div class="text-center">
          <div class="badge bg-${color} fs-4 px-4 py-3 d-block mb-1" style="min-width: 100px;">${tag}</div>
          <div class="fw-bold fs-5">${count}<small class="text-muted">äºº</small></div>
          <div class="text-muted small">${pct}%</div>
        </div>`;
      });

      html += `</div>`;
      container.innerHTML = html;
    }

    // =========================================================
    // FULLSCREEN: QUADRANT (Left-Right)
    // å¤§ããªæ•£å¸ƒå›³ + æ„è¦‹ã‚«ãƒ¼ãƒ‰
    // =========================================================
    _fsQuadrantViz(container, opinions, opts) {
      const xMin = opts.xAxisLabel?.[0] || 'å·¦';
      const xMax = opts.xAxisLabel?.[1] || 'å³';
      const yMin = opts.yAxisLabel?.[0] || 'ä¸‹';
      const yMax = opts.yAxisLabel?.[1] || 'ä¸Š';

      let html = `
        <div class="w-100 px-3">
          <div class="text-center mb-2">
            <span class="badge bg-primary bg-opacity-10 text-primary fs-6 px-3 py-2">
              <i class="bi bi-people-fill me-1"></i>${opinions.length}äººã®<ruby>å›ç­”<rt>ã‹ã„ã¨ã†</rt></ruby>
            </span>
          </div>
          <div class="position-relative mx-auto" style="width: 100%; max-width: 450px; aspect-ratio: 1/1;">
            <div class="w-100 h-100 bg-light border rounded position-relative" style="border-width: 2px !important;">
              <div class="position-absolute top-50 start-0 w-100 border-top border-secondary" style="opacity: 0.4;"></div>
              <div class="position-absolute start-50 top-0 h-100 border-start border-secondary" style="opacity: 0.4;"></div>
              <span class="position-absolute top-50 start-0 translate-middle-y bg-white px-2 py-1 rounded border fw-bold" style="margin-left: 4px; font-size: 1rem;">${xMin}</span>
              <span class="position-absolute top-50 end-0 translate-middle-y bg-white px-2 py-1 rounded border fw-bold" style="margin-right: 4px; font-size: 1rem;">${xMax}</span>
              <span class="position-absolute top-0 start-50 translate-middle-x bg-white px-2 py-1 rounded border fw-bold" style="margin-top: 4px; font-size: 1rem;">${yMax}</span>
              <span class="position-absolute bottom-0 start-50 translate-middle-x bg-white px-2 py-1 rounded border fw-bold" style="margin-bottom: 4px; font-size: 1rem;">${yMin}</span>`;

      opinions.forEach((op, idx) => {
        const val = this._parseValue(op.value);
        if (val && typeof val === 'object') {
          const left = ((Number(val.x) + 100) / 200) * 100;
          const top = ((100 - Number(val.y)) / 200) * 100;
          const hue = (idx * 37) % 360;
          html += `<div class="position-absolute rounded-circle border border-2 border-white shadow"
            style="width: 20px; height: 20px; left: ${left}%; top: ${top}%; transform: translate(-50%, -50%); background: hsl(${hue}, 70%, 55%); opacity: 0.85;"></div>`;
        }
      });

      html += `</div></div></div>`;
      container.innerHTML = html;
    }

    // =========================================================
    // FULLSCREEN: RANKING (Top-Bottom)
    // é›†è¨ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒãƒ¼ï¼ˆå¤§ï¼‰+ æ„è¦‹ã‚«ãƒ¼ãƒ‰
    // =========================================================
    _fsRankingViz(container, opinions, opts) {
      const scores = {};
      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && val.items) {
          val.items.forEach((item, idx) => {
            if (!scores[item]) scores[item] = 0;
            scores[item] += Math.max(val.items.length - idx, 1);
          });
        }
      });

      const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);

      let html = `
        <div class="text-center mb-3">
          <span class="badge bg-primary bg-opacity-10 text-primary fs-5 px-4 py-2">
            <i class="bi bi-people-fill me-1"></i>${opinions.length}äººã®<ruby>å›ç­”<rt>ã‹ã„ã¨ã†</rt></ruby>ã‚’<ruby>é›†è¨ˆ<rt>ã—ã‚…ã†ã‘ã„</rt></ruby>
          </span>
        </div>`;

      if (sorted.length > 0) {
        const maxScore = sorted[0][1];
        sorted.forEach(([item, score], idx) => {
          const pct = Math.round((score / maxScore) * 100);
          const medal = idx === 0 ? '<span style="font-size:1.5rem;">&#x1F947;</span>'
            : idx === 1 ? '<span style="font-size:1.5rem;">&#x1F948;</span>'
              : idx === 2 ? '<span style="font-size:1.5rem;">&#x1F949;</span>'
                : `<span class="fs-5 fw-bold text-muted">${idx + 1}.</span>`;
          const barColor = idx === 0 ? 'bg-warning' : idx === 1 ? 'bg-secondary' : idx === 2 ? 'bg-orange' : 'bg-primary bg-opacity-50';

          html += `<div class="d-flex align-items-center mb-3">
            <span class="me-3 text-center" style="min-width: 36px;">${medal}</span>
            <div class="flex-grow-1">
              <div class="d-flex justify-content-between mb-1">
                <span class="fw-bold fs-5">${item}</span>
                <span class="text-muted fs-6">${score}pt</span>
              </div>
              <div class="progress" style="height: 14px; border-radius: 8px;">
                <div class="progress-bar ${idx < 3 ? 'bg-primary' : 'bg-primary bg-opacity-50'}" style="width: ${pct}%; border-radius: 8px;"></div>
              </div>
            </div>
          </div>`;
        });
      }

      container.innerHTML = html;
    }

    // =========================================================
    // FULLSCREEN: CURVE (Top-Bottom)
    // é‡ã­åˆã‚ã›æŠ˜ã‚Œç·šãƒãƒ£ãƒ¼ãƒˆï¼ˆå¤§ï¼‰+ æ„è¦‹ã‚«ãƒ¼ãƒ‰
    // =========================================================
    _fsCurveViz(container, opinions, opts) {
      const scenes = opts.scenes || ['ã¯ã˜ã‚', 'å±•é–‹', 'å±±å ´', 'çµæœ«'];
      const canvasId = 'fs-curve-chart-' + Date.now();

      container.innerHTML = `
        <div class="text-center mb-3">
          <span class="badge bg-primary bg-opacity-10 text-primary fs-5 px-4 py-2">
            <i class="bi bi-people-fill me-1"></i>${opinions.length}äººã®<ruby>å¿ƒæƒ…æ›²ç·š<rt>ã—ã‚“ã˜ã‚‡ã†ãã‚‡ãã›ã‚“</rt></ruby>
          </span>
        </div>
        <div style="height: 280px;"><canvas id="${canvasId}"></canvas></div>`;

      setTimeout(() => {
        const ctx = document.getElementById(canvasId);
        if (!ctx) return;

        const datasets = [];
        const avgData = new Array(scenes.length).fill(0);
        let count = 0;

        opinions.forEach((op, idx) => {
          const val = this._parseValue(op.value);
          if (val && val.data) {
            const data = val.data.map(d => d.value);
            data.forEach((v, i) => { if (i < avgData.length) avgData[i] += v; });
            count++;
            datasets.push({
              data: data,
              borderColor: `hsla(${(idx * 37) % 360}, 70%, 60%, 0.3)`,
              borderWidth: 1.5,
              pointRadius: 0,
              tension: 0.3,
              fill: false
            });
          }
        });

        if (count > 0) {
          datasets.push({
            label: 'ã¿ã‚“ãªã®å¹³å‡',
            data: avgData.map(v => Math.round(v / count)),
            borderColor: 'rgb(220, 53, 69)',
            borderWidth: 4,
            pointRadius: 6,
            pointBackgroundColor: 'rgb(220, 53, 69)',
            tension: 0.3,
            fill: false
          });
        }

        new Chart(ctx, {
          type: 'line',
          data: { labels: scenes, datasets: datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { min: 0, max: 100, ticks: { font: { size: 14 } } },
              x: { ticks: { font: { size: 16, weight: 'bold' } } }
            },
            plugins: {
              legend: { display: true, position: 'top', labels: { font: { size: 14 } } }
            },
            animation: false
          }
        });
      }, 150);
    }

    // =========================================================
    // FULLSCREEN: MANDALA (Left-Right)
    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¦ãƒ‰ï¼ˆå¤§ï¼‰+ æ„è¦‹ã‚«ãƒ¼ãƒ‰
    // =========================================================
    _fsMandalaViz(container, opinions, opts) {
      const wordCounts = {};
      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && val.items) {
          val.items.filter(v => v && v.trim()).forEach(item => {
            const word = item.trim();
            wordCounts[word] = (wordCounts[word] || 0) + 1;
          });
        }
      });

      const sorted = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]);
      const maxCount = sorted.length > 0 ? sorted[0][1] : 1;

      let html = `
        <div class="w-100 px-3">
          <div class="text-center mb-3">
            <span class="badge bg-primary bg-opacity-10 text-primary fs-6 px-3 py-2">
              <i class="bi bi-people-fill me-1"></i>${opinions.length}äººã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            </span>
          </div>`;

      if (opts.centerTheme) {
        html += `<div class="text-center mb-3">
          <span class="badge bg-primary fs-4 px-4 py-3">${opts.centerTheme}</span>
        </div>`;
      }

      html += `<div class="d-flex flex-wrap gap-2 justify-content-center px-2">`;
      sorted.slice(0, 25).forEach(([word, count]) => {
        const ratio = count / maxCount;
        const fontSize = ratio >= 0.8 ? '1.8rem' : ratio >= 0.5 ? '1.4rem' : ratio >= 0.3 ? '1.1rem' : '0.95rem';
        const opacity = ratio >= 0.5 ? '1' : '0.85';
        html += `<span class="badge bg-warning text-dark shadow-sm" style="font-size: ${fontSize}; padding: 8px 14px; opacity: ${opacity};">${word}<sup class="ms-1 text-muted">${count}</sup></span>`;
      });
      html += `</div></div>`;

      container.innerHTML = html;
    }

    // =========================================================
    // FULLSCREEN: ACTION (Top-Bottom, ã‚«ãƒ¼ãƒ‰ã®ã¿)
    // å®£è¨€ã‚«ãƒ¼ãƒ‰ã‚’å¤§ããä¸¦ã¹ã‚‹
    // =========================================================
    _fsActionCards(container, opinions) {
      let html = `
        <div class="text-center mb-3">
          <span class="badge bg-success bg-opacity-10 text-success fs-5 px-4 py-2">
            <i class="bi bi-megaphone-fill me-1"></i>${opinions.length}äººã®<ruby>è¡Œå‹•å®£è¨€<rt>ã“ã†ã©ã†ã›ã‚“ã’ã‚“</rt></ruby>
          </span>
        </div>
        <div class="row g-3">`;

      opinions.forEach(op => {
        const val = this._parseValue(op.value);
        if (val && typeof val === 'object') {
          html += `<div class="col-md-6">
            <div class="bg-white rounded-3 p-3 shadow-sm border-start border-4 border-success h-100">
              <div class="fw-bold text-success mb-2 fs-6"><i class="bi bi-megaphone-fill me-1"></i><ruby>è¡Œå‹•å®£è¨€<rt>ã“ã†ã©ã†ã›ã‚“ã’ã‚“</rt></ruby></div>
              ${val.when ? `<div class="mb-1 fs-6"><span class="text-muted me-1"><i class="bi bi-clock"></i> ã„ã¤:</span>${val.when}</div>` : ''}
              ${val.who ? `<div class="mb-1 fs-6"><span class="text-muted me-1"><i class="bi bi-person"></i> ã ã‚Œã«:</span>${val.who}</div>` : ''}
              ${val.what ? `<div class="fw-bold fs-5 mt-2 text-success"><i class="bi bi-check-circle me-1"></i>${val.what}</div>` : ''}
              ${op.text ? `<div class="small text-muted mt-2 pt-2 border-top">${op.text}</div>` : ''}
            </div>
          </div>`;
        }
      });

      html += `</div>`;
      container.innerHTML = html;
    }

    // =========================================================
    // FULLSCREEN: å…±é€šãƒ†ã‚­ã‚¹ãƒˆæ„è¦‹ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ
    // =========================================================
    _fsTextCards(container, opinions, patternType) {
      const withText = opinions.filter(op => op.text && op.text.trim());

      let headerHtml = `<div class="d-flex justify-content-between align-items-center mb-3 mt-2">
        <h6 class="fw-bold text-muted mb-0 fs-5"><i class="bi bi-chat-left-text me-2"></i>ã¿ã‚“ãªã®<ruby>æ„è¦‹<rt>ã„ã‘ã‚“</rt></ruby></h6>
        <span class="badge bg-light text-dark border">${withText.length}<small>ä»¶</small></span>
      </div>`;

      if (withText.length === 0) {
        container.innerHTML = headerHtml + '<div class="text-center text-muted fs-6 py-3">ãƒ†ã‚­ã‚¹ãƒˆã®æ„è¦‹ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }

      let html = headerHtml;
      withText.forEach(op => {
        const badge = this._fsBadge(op, patternType);
        html += `<div class="fs-opinion-card">
          <div class="mb-1">${badge}</div>
          <div class="fs-opinion-text">${op.text}</div>
        </div>`;
      });

      container.innerHTML = html;
    }

    // ãƒãƒƒã‚¸ç”Ÿæˆï¼ˆãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ç”¨ï¼‰
    _fsBadge(op, patternType) {
      const val = this._parseValue(op.value);

      switch (patternType) {
        case 'SLIDER':
          return `<span class="badge bg-primary rounded-pill fs-6 me-1">${op.value}</span>`;
        case 'TAGS':
          return `<span class="badge bg-info text-dark fs-6 me-1">${op.value}</span>`;
        case 'QUADRANT':
          return val && typeof val === 'object'
            ? `<span class="badge bg-secondary fs-6 me-1">x:${val.x} y:${val.y}</span>` : '';
        case 'RANKING':
          return val?.items?.[0]
            ? `<span class="badge bg-primary fs-6 me-1">1<ruby>ä½<rt>ã„</rt></ruby>: ${val.items[0]}</span>` : '';
        case 'CURVE':
          return `<span class="badge bg-secondary fs-6 me-1"><ruby>å¿ƒæƒ…æ›²ç·š<rt>ã—ã‚“ã˜ã‚‡ã†ãã‚‡ãã›ã‚“</rt></ruby></span>`;
        case 'MANDALA': {
          const preview = val?.items?.filter(v => v).slice(0, 2).join(', ') || '';
          return preview ? `<span class="badge bg-warning text-dark fs-6 me-1">${preview}...</span>` : '';
        }
        default:
          return `<span class="badge bg-secondary fs-6 me-1">${op.value}</span>`;
      }
    }
  }

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
  const patternRenderer = new PatternRenderer();
</script>